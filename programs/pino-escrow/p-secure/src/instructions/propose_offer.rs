use core::mem::{transmute, size_of};

use pinocchio::{
    AccountView, Address, ProgramResult, cpi::Seed, cpi::Signer, error::ProgramError,
    sysvars::{Sysvar, rent::Rent}
};
use pinocchio_token::{instructions::TransferChecked, state::Mint};

use crate::state::MakeState;


// Account context for the Offer instruction
//
// This struct defines all accounts involved in creating an escrow offer.
// Each account has specific validation requirements that we check manually.
//
// In Anchor, this would be generated by #[derive(Accounts)]
// In Pinocchio, we write all validation logic manually.
//
// Remember proposer is Sarah in this context


pub struct OfferAccounts<'a> {
    // The person creating the escrow offer - must sign the transaction (Sarah)
    pub maker: &'a AccountView,

    // Token mint A - what Sarah is offering
    pub token_mint_a: &'a AccountView,

    // Token mint B - what Sarah wants in return
    pub token_mint_b: &'a AccountView,

    // Sarah's associated token account for Token A (source of funds)
    pub maker_ata_a: &'a AccountView,

    // The escrow offer PDA account (will be created)
    pub offer: &'a AccountView,

    // The vault ATA that will hold the escrowed tokens (will be created) until deal is done
    pub vault: &'a AccountView,
    pub token_program: &'a AccountView,
    pub system_program: &'a AccountView,
}

// Implement TryFrom trait to convert from raw account array to our typed context
//
// This performs all account validation in one place:
// - Signer checks
// - Ownership validation
// - PDA derivation and verification
// - Account state validation (initialized/uninitialized)
// - Writability checks
//
// Converting FROM: &'a[AccountView] (what runtime gives us)
// Converting TO: OfferAccounts<'a> (our validated, typed struct)
//
// Anchor's #[derive(Accounts)] macro generates similar code automatically
// In Pinocchio, we write it manually


impl<'a> TryFrom<&'a [AccountView]> for OfferAccounts<'a> {
    type Error = ProgramError;

    fn try_from(accounts: &'a [AccountView]) -> Result<Self, Self::Error> {

        // Destructure account array with pattern matching
        // The trailing underscore _ ignores any extra accounts
        let [maker, token_mint_a, token_mint_b, maker_ata_a, offer, vault, token_program, system_program, _] =
            accounts
        else {
            return Err(ProgramError::NotEnoughAccountKeys);
        };

        // SECURITY CHECKS

        // 1: Signer Check
        // Ensures only the actual maker can create an escrow offer
        if !maker.is_signer() {
            return Err(ProgramError::MissingRequiredSignature);
        }


        // 2: Token Mint Ownership
        // Verifies both token mints are owned by the SPL Token program
        // Prevents attackers from passing fake mint accounts
        if !token_mint_a.owned_by(token_program.address()) {
            return Err(ProgramError::InvalidAccountOwner);
        }

        if !token_mint_b.owned_by(token_program.address()) {
            return Err(ProgramError::InvalidAccountOwner);
        }


        // 3: Maker's Token Account Validation
        // Owner check ensures the account belongs to SPL Token Program
        if !maker_ata_a.owned_by(token_program.address()) {
            return Err(ProgramError::InvalidAccountOwner);
        }

        // Size check ensures correct data layout for a TokenAccount
        if maker_ata_a.data_len() != pinocchio_token::state::TokenAccount::LEN {
            return Err(ProgramError::InvalidAccountData);
        }


        // 4: Maker's ATA Address Derivation
        // Derives the expected ATA address and verifies it matches
        // Prevents maker from passing someone else's token account
        let (expected_maker_ata, _) = Address::find_program_address(
            &[
                maker.address().as_array(),
                token_program.address().as_array(),
                token_mint_a.address().as_array(),
            ],
            &pinocchio_associated_token_account::ID,
        );

        if expected_maker_ata.ne(maker_ata_a.address()) {
            return Err(ProgramError::InvalidAccountData);
        }


        // 5: Offer PDA Uninitialized Check
        // Ensures the offer PDA doesn't exist yet
        // Prevents overwriting existing offer data
        if !offer.is_data_empty() {
            return Err(ProgramError::AccountAlreadyInitialized);
        }


        // 6: Offer Account Writable Check
        // Ensures write permission to create and initialize the account
        if !offer.is_writable() {
            return Err(ProgramError::InvalidAccountData);
        }


        // 7: Vault ATA Address Derivation
        // Vault is derived from offer PDA, ensuring each offer has its own unique vault
        // Prevents sending tokens to wrong vault
        let (expected_vault, _) = Address::find_program_address(
            &[
                offer.address().as_array(),
                token_program.address().as_array(),
                token_mint_a.address().as_array(),
            ],
            &pinocchio_associated_token_account::ID,
        );

        if expected_vault.ne(vault.address()) {
            return Err(ProgramError::InvalidAccountData);
        }


        // 8: Vault Uninitialized & Writable Checks
        // Ensures vault ATA doesn't exist yet and can be written to
        if !vault.is_data_empty() {
            return Err(ProgramError::AccountAlreadyInitialized);
        }

        if !vault.is_writable() {
            return Err(ProgramError::InvalidAccountData);
        }


        // All validations passed
        Ok(Self {
            maker,
            token_mint_a,
            token_mint_b,
            maker_ata_a,
            offer,
            vault,
            token_program,
            system_program,
        })
    }
}


// Instruction data for proposing an escrow offer
//
// This is similar to Anchor's instruction parameters, but we parse it manually.
// The client sends this data as raw bytes, and we deserialize it here.

#[repr(C)]
#[derive(Clone, Copy)]
pub struct ProposalOfferData {
    // Unique identifier for this escrow (used in PDA derivation)
    pub id: [u8; 8],

    // Amount of Token B the maker wants to receive
    pub token_b_wanted_amount: u64,

    // Amount of Token A the maker is offering
    pub token_a_offered_amount: u64,

    pub bump: u8,
}

impl ProposalOfferData {
    pub const LEN: usize = core::mem::size_of::<ProposalOfferData>();
}

// Parse instruction data from raw bytes
//
// Uses unsafe transmute for zero-copy deserialization.
// bytemuck would not work normally cause of the extra padding in the bytes
// Safe because:
// 1. We validate the length matches exactly
// 2. #[repr(C)] ensures predictable layout
// 3. All fields are POD types

impl<'a> TryFrom<&'a [u8]> for ProposalOfferData {
    type Error = ProgramError;
    fn try_from(data: &'a [u8]) -> Result<Self, Self::Error> {
        Ok(unsafe {
            transmute(
                TryInto::<[u8; size_of::<ProposalOfferData>()]>::try_into(data)
                    .map_err(|_| ProgramError::InvalidInstructionData)?,
            )
        })
    }
}


// Complete instruction context - combines validated accounts and parsed data
//
// This is the final structure passed to the instruction handler.
// Similar to Anchor's Context<T> type.
pub struct ProposeOfferInstruction<'a> {
    pub accounts: OfferAccounts<'a>,
    pub data: ProposalOfferData,
}

// Parse both accounts and instruction data together
impl<'a> TryFrom<(&'a [AccountView], &'a [u8])> for ProposeOfferInstruction<'a> {
    type Error = ProgramError;

    fn try_from(
        (accounts, data): (&'a [AccountView], &'a [u8]),
    ) -> Result<Self, Self::Error> {
        let accounts = OfferAccounts::try_from(accounts)?;
        let data = ProposalOfferData::try_from(data)?;

        Ok(Self { accounts, data })
    }
}


// INSTRUCTION HANDLER


impl<'a> ProposeOfferInstruction<'a> {

    // Execute the Propose Offer instruction
    pub fn handler(&self) -> ProgramResult {

        // 1: Verify Offer PDA Address
        // Derives canonical PDA with proper seeds and verifies the provided offer account matches
        // Uses find_program_address to get canonical bump
        let (expected_offer_address, bump) = Address::find_program_address(
            &[
                MakeState::SEED_PREFIX,
                self.accounts.maker.address().as_array(),
                &self.data.id,
            ],
            &crate::ID,
        );

        if expected_offer_address.ne(self.accounts.offer.address()) {
            return Err(ProgramError::InvalidAccountData);
        }


        // 2: Calculate rent for offer account
        let rent = Rent::get()?;
        let space = MakeState::LEN;
        let lamports = rent.try_minimum_balance(space)?;


        // 3: Create the offer PDA account
        pinocchio_system::instructions::CreateAccount {
            from: self.accounts.maker,
            to: self.accounts.offer,
            space: space as u64,
            lamports,
            owner: &crate::ID,
        }
        .invoke_signed(&[Signer::from(&[
            Seed::from(MakeState::SEED_PREFIX),
            Seed::from(self.accounts.maker.address().as_array()),
            Seed::from(&self.data.id),
            Seed::from(&[bump]),
        ])])?;


        // 4: Initialize the offer state
        // Drop borrow before CPI to avoid runtime borrow conflicts
        {
            let mut offer_data = self.accounts.offer.try_borrow_mut()?;
            let offer_state = MakeState::load_mut(&mut offer_data)?;

            offer_state.set_inner(
                self.data.id,
                *self.accounts.maker.address(),
                *self.accounts.token_mint_a.address(),
                *self.accounts.token_mint_b.address(),
                self.data.token_b_wanted_amount,
                self.data.token_a_offered_amount,
                bump,
            );
        }


        // 5: Create the vault ATA
        pinocchio_associated_token_account::instructions::Create {
            account: self.accounts.vault,
            funding_account: self.accounts.maker,
            mint: self.accounts.token_mint_a,
            token_program: self.accounts.token_program,
            system_program: self.accounts.system_program,
            wallet: self.accounts.offer,
        }
        .invoke()?;


        // 6: Transfer tokens from maker to vault
        // Uses TransferChecked instead of Transfer to validate mint and decimals
        // Prevents token mismatch attacks
        TransferChecked {
            from: self.accounts.maker_ata_a,
            to: self.accounts.vault,
            authority: self.accounts.maker,
            mint: self.accounts.token_mint_a,
            amount: self.data.token_a_offered_amount,
            decimals: Mint::from_account_view(self.accounts.token_mint_a)?.decimals(),
        }
        .invoke()?;

        Ok(())
    }
}
