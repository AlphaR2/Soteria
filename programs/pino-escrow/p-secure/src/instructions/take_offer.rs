use pinocchio::{
    AccountView,
    Address,
    ProgramResult,
    cpi::{Seed, Signer},
    error::ProgramError,
};
use pinocchio_token::{
    instructions::{TransferChecked, CloseAccount},
    state::{Mint, TokenAccount},
};

use crate::state::MakeState;

// Account context for the Take Offer instruction
//
// This struct defines all accounts involved in accepting/taking an escrow offer.
// The taker (Steve) provides Token B and receives Token A from the vault.
//
// Flow:
// 1. Taker sends Token B -> Proposer's ATA B
// 2. Vault sends Token A -> Taker's ATA A
// 3. Vault is closed (rent returned to proposer)
// 4. Offer PDA is closed (rent returned to taker as compensation)
//
// In Anchor, this would be generated by #[derive(Accounts)]
// In Pinocchio, we write all validation logic manually.
pub struct TakeOfferAccounts<'a> {
    pub taker: &'a AccountView,
    pub proposer: &'a AccountView,        // Original proposer (Sarah)
    pub proposer_ata_b: &'a AccountView,  // Sarah's Token B account
    pub token_mint_b: &'a AccountView,
    pub token_mint_a: &'a AccountView,
    pub taker_ata_a: &'a AccountView,
    pub taker_ata_b: &'a AccountView,
    pub offer: &'a AccountView,
    pub vault: &'a AccountView,           // Vault holding Token A
    pub token_program: &'a AccountView,
    pub system_program: &'a AccountView,
}

// Converting FROM: &'a[AccountView] (what runtime gives us)
// Converting TO: TakeOfferAccounts<'a> (our validated, typed struct)
impl<'a> TryFrom<&'a [AccountView]> for TakeOfferAccounts<'a> {
    type Error = ProgramError;

    fn try_from(accounts: &'a [AccountView]) -> Result<Self, Self::Error> {
        // Destructure account array
        let [taker, proposer, proposer_ata_b, token_mint_b, token_mint_a, taker_ata_a, taker_ata_b, offer, vault, token_program, system_program, ..] =
            accounts
        else {
            return Err(ProgramError::NotEnoughAccountKeys);
        };

        // SECURITY CHECKS

        // 1: Signer Check
        // Only the actual taker can accept an offer
        if !taker.is_signer() {
            return Err(ProgramError::MissingRequiredSignature);
        }



        // 2: Token Mint Ownership
        // Validates both mints are legitimate SPL Token mints
        if !token_mint_a.owned_by(token_program.address()) {
            return Err(ProgramError::InvalidAccountOwner);
        }

        if !token_mint_b.owned_by(token_program.address()) {
            return Err(ProgramError::InvalidAccountOwner);
        }


        // 3: Offer Account Checks
        // Owner check ensures offer is owned by this program (not a fake)
        if !offer.owned_by(&crate::ID) {
            return Err(ProgramError::InvalidAccountOwner);
        }

        // Size check ensures correct data layout
        if offer.data_len() != MakeState::LEN {
            return Err(ProgramError::InvalidAccountData);
        }

        // Writable check for closing the offer later
        if !offer.is_writable() {
            return Err(ProgramError::InvalidAccountData);
        }

        // 4: Load and Validate Offer State
        // Validates stored state matches provided accounts
        let (offer_state_proposer, offer_state_mint_b) = {
            let offer_data = offer.try_borrow()?;
            let offer_state = MakeState::load(&offer_data)?;

            // Active check prevents double-spend on closed offers
            if !offer_state.is_active() {
                return Err(ProgramError::InvalidAccountData);
            }

            // Proposer check ensures correct original maker
            if offer_state.proposer.ne(proposer.address()) {
                return Err(ProgramError::InvalidAccountData);
            }

            // Mint checks prevent token substitution attacks
            if offer_state.token_mint_a.ne(token_mint_a.address()) {
                return Err(ProgramError::InvalidAccountData);
            }

            if offer_state.token_mint_b.ne(token_mint_b.address()) {
                return Err(ProgramError::InvalidAccountData);
            }

            // Return values for next validation
            (offer_state.proposer, offer_state.token_mint_b)
        };


        // 5: Proposer ATA B - Address Derivation
        // Derives proposer's Token B ATA from stored state
        // Ensures tokens go to the correct recipient
        // Proposer might not have Token B account yet!
        let (expected_proposer_ata_b, _) = Address::find_program_address(
            &[
                offer_state_proposer.as_array(),
                token_program.address().as_array(),
                offer_state_mint_b.as_array(),
            ],
            &pinocchio_associated_token_account::ID,
        );

        if expected_proposer_ata_b.ne(proposer_ata_b.address()) {
            return Err(ProgramError::InvalidAccountData);
        }

        // 6: Taker ATA A - Ownership & Address
        // Four-part validation: owner, size, writable, and address derivation
        if !taker_ata_a.owned_by(token_program.address()) {
            return Err(ProgramError::InvalidAccountOwner);
        }

        if taker_ata_a.data_len() != TokenAccount::LEN {
            return Err(ProgramError::InvalidAccountData);
        }

        if !taker_ata_a.is_writable() {
            return Err(ProgramError::InvalidAccountData);
        }

        let (expected_taker_ata_a, _) = Address::find_program_address(
            &[
                taker.address().as_array(),
                token_program.address().as_array(),
                token_mint_a.address().as_array(),
            ],
            &pinocchio_associated_token_account::ID,
        );

        if expected_taker_ata_a.ne(taker_ata_a.address()) {
            return Err(ProgramError::InvalidAccountData);
        }

        // 7: Taker ATA B - Ownership, Address & Balance
        // Owner, size, and address derivation for taker's Token B source account
        if !taker_ata_b.owned_by(token_program.address()) {
            return Err(ProgramError::InvalidAccountOwner);
        }

        if taker_ata_b.data_len() != TokenAccount::LEN {
            return Err(ProgramError::InvalidAccountData);
        }

        let (expected_taker_ata_b, _) = Address::find_program_address(
            &[
                taker.address().as_array(),
                token_program.address().as_array(),
                token_mint_b.address().as_array(),
            ],
            &pinocchio_associated_token_account::ID,
        );

        if expected_taker_ata_b.ne(taker_ata_b.address()) {
            return Err(ProgramError::InvalidAccountData);
        }

        // Verify taker has sufficient Token B balance
        {
            let offer_data = offer.try_borrow()?;
            let offer_state = MakeState::load(&offer_data)?;

            let taker_token_account = TokenAccount::from_account_view(taker_ata_b)?;

            if taker_token_account.amount() < offer_state.token_b_wanted_amount {
                return Err(ProgramError::InsufficientFunds);
            }
        }


        // 8: Vault - Ownership, Address & Balance
        // Full validation of vault: owner, size, writable, and address derivation from offer PDA
        if !vault.owned_by(token_program.address()) {
            return Err(ProgramError::InvalidAccountOwner);
        }

        if vault.data_len() != TokenAccount::LEN {
            return Err(ProgramError::InvalidAccountData);
        }

        if !vault.is_writable() {
            return Err(ProgramError::InvalidAccountData);
        }

        let (expected_vault, _) = Address::find_program_address(
            &[
                offer.address().as_array(),
                token_program.address().as_array(),
                token_mint_a.address().as_array(),
            ],
            &pinocchio_associated_token_account::ID,
        );

        if expected_vault.ne(vault.address()) {
            return Err(ProgramError::InvalidAccountData);
        }

        // Verify vault has sufficient Token A balance
        {
            let offer_data = offer.try_borrow()?;
            let offer_state = MakeState::load(&offer_data)?;

            let vault_token_account = TokenAccount::from_account_view(vault)?;

            if vault_token_account.amount() < offer_state.token_a_offered_amount {
                return Err(ProgramError::InsufficientFunds);
            }
        }

        // All validations passed
        Ok(Self {
            taker,
            proposer,
            proposer_ata_b,
            token_mint_b,
            token_mint_a,
            taker_ata_a,
            taker_ata_b,
            offer,
            vault,
            token_program,
            system_program,
        })
    }
}

// Take Offer Instruction
pub struct TakeOfferInstruction<'a> {
    pub accounts: TakeOfferAccounts<'a>,
}

impl<'a> TryFrom<(&'a [AccountView], &'a [u8])> for TakeOfferInstruction<'a> {
    type Error = ProgramError;

    fn try_from(
        (accounts, _data): (&'a [AccountView], &'a [u8]),
    ) -> Result<Self, Self::Error> {
        let accounts = TakeOfferAccounts::try_from(accounts)?;

        Ok(Self { accounts })
    }
}


// INSTRUCTION HANDLER

impl<'a> TakeOfferInstruction<'a> {
    pub fn handler(&self) -> ProgramResult {

        // 1: Load Offer State
        let offer_data = self.accounts.offer.try_borrow()?;
        let offer_state = MakeState::load(&offer_data)?;

        // Double-checks active status in handler to prevent race conditions
        if !offer_state.is_active() {
            return Err(ProgramError::InvalidAccountData);
        }

        let token_b_amount = offer_state.token_b_wanted_amount;
        let token_a_amount = offer_state.token_a_offered_amount;
        let bump = offer_state.bump;
        let offer_id = offer_state.id;

        // Explicitly drops the borrow before making CPIs to avoid runtime borrow conflicts
        drop(offer_data);


        // 2: Create Proposer's ATA B if Needed
        // Create the ATA for token B if Sarah does not have it yet
        if self.accounts.proposer_ata_b.is_data_empty() {
            pinocchio_associated_token_account::instructions::Create {
                account: self.accounts.proposer_ata_b,
                funding_account: self.accounts.taker,
                mint: self.accounts.token_mint_b,
                token_program: self.accounts.token_program,
                system_program: self.accounts.system_program,
                wallet: self.accounts.proposer,
            }
            .invoke()?;
        }

        // 3: Transfer Token B from Taker to Proposer
        TransferChecked {
            from: self.accounts.taker_ata_b,
            to: self.accounts.proposer_ata_b,
            authority: self.accounts.taker,
            mint: self.accounts.token_mint_b,
            amount: token_b_amount,
            decimals: Mint::from_account_view(self.accounts.token_mint_b)?.decimals(),
        }
        .invoke()?;


        // 4: Prepare PDA Signer
        let bump_binding = [bump];
        let seeds = [
            Seed::from(MakeState::SEED_PREFIX),
            Seed::from(self.accounts.proposer.address().as_array()),
            Seed::from(&offer_id),
            Seed::from(&bump_binding),
        ];
        let signer = Signer::from(&seeds);


        // 5: Transfer Token A from Vault to Taker
        // Vault transfers are PDA-signed, ensuring only the escrow program can release funds
        let vault_amount = TokenAccount::from_account_view(self.accounts.vault)?.amount();
        let transfer_amount = vault_amount.min(token_a_amount);

        TransferChecked {
            from: self.accounts.vault,
            to: self.accounts.taker_ata_a,
            authority: self.accounts.offer,
            mint: self.accounts.token_mint_a,
            amount: transfer_amount,
            decimals: Mint::from_account_view(self.accounts.token_mint_a)?.decimals(),
        }
        .invoke_signed(&[signer.clone()])?;


        // 6: Close Vault Account
        CloseAccount {
            account: self.accounts.vault,
            destination: self.accounts.proposer,
            authority: self.accounts.offer,
        }
        .invoke_signed(&[signer])?;

        // 7: Close Offer Account
        // Complete closure procedure:
        // - Marks data as invalid (0xff discriminator)
        // - Transfers rent to taker (compensation for gas)
        // - Zeroes lamports to prevent reuse
        // - Resizes to 0 and closes account
        {
            let mut offer_data = self.accounts.offer.try_borrow_mut()?;
            offer_data[0] = 0xff;
        }

        let lamports = self.accounts.offer.lamports();
        self.accounts.taker.set_lamports(
            self.accounts.taker.lamports().saturating_add(lamports)
        );

        // Zero out offer lamports
        self.accounts.offer.set_lamports(0);

        // Resize account to 0 bytes
        self.accounts.offer.resize(0)?;

        // Close the account
        self.accounts.offer.close()?;

        Ok(())
    }
}
